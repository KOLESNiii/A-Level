1.1 Systems architecture
1.1.1 Architecture of the CPU
The purpose of the CPU:\nThe fetch-execute cycle\nCommon CPU components and their function:\nALU (Arithmetic Logic Unit)\nCU (Control Unit)\nCache\nRegisters\nVon Neumann architecture:\nMAR (Memory Address Register)\nMDR (Memory Data Register)\nProgram Counter\nAccumulator
1.1.2 CPU performance
How common characteristics of CPUs affect their performance:\nClock speed\nCache size\nNumber of cores
1.1.3 Embedded systems
The purpose and characteristics of embedded systems\nExamples of embedded systems
1.2 Memory and storage
1.2.1 Primary storage (Memory)
The need for primary storage\nThe difference between RAM and ROM\nThe purpose of\nROM in a computer system\nThe purpose of RAM in a computer system\nVirtual memory
1.2.2 Secondary storage
The need for secondary storage\nCommon types of storage:\n   Optical\n   Magnetic\n   Solid state\nSuitable storage devices and storage media for a given application\nThe advantages and disadvantages of different storage devices and storage media relating to these characteristics:\n   Capacity\n   Speed\n   Portability\n   Durability\n   Reliability\n   Cost
1.2.3 Units
The units of data storage:\n   Bit\n   Nibble (4 bits)\n   Byte (8 bits)\n   Kilobyte (1,000 bytes or 1 KB)\n   Megabyte (1,000 KB)\n   Gigabyte (1,000 MB)\n   Terabyte (1,000 GB)\n   Petabyte (1,000 TB)\nHow data needs to be converted into a binary format to be processed by a computer\nData capacity and calculation of data capacity requirements
1.2.4 Data storage
Numbers\nHow to convert positive denary whole numbers to binary numbers (up to and including 8 bits) and vice versa\nHow to add two binary integers together (up to and including 8 bits) and explain overflow errors which may occur\nHow to convert positive denary whole numbers into 2-digit\nhexadecimal numbers and vice versa\nHow to convert binary integers to their hexadecimal equivalents and vice versa\nBinary shifts\n\nCharacters\nThe use of binary codes to represent characters\nThe term ‘character set’\nThe relationship between the number of bits per character in a\ncharacter set, and the number of characters which can be\nrepresented, e.g.:\n   ASCII\n   Unicode\n\nImages\nHow an image is represented as a series of pixels, represented in binary\nMetadata\nThe effect of colour depth and resolution on:\n   The quality of the image\n   The size of an image file\n\nSound\nHow sound can be sampled and stored in digital form\nThe effect of sample rate, duration and bit depth on:\n   The playback quality\n   The size of a sound file
1.2.5 Compression 
The need for compression\nTypes of compression:\n   Lossy\n   Lossless
1.3 Computer networks, connections and protocols
1.3.1 Networks and topologies
Types of network:\n   LAN (Local Area Network)\n   WAN (Wide Area Network)\nFactors that affect the performance of networks\nThe different roles of computers in a client-server and a peer-topeer network\nThe hardware needed to connect stand-alone computers into a Local Area Network:\n   Wireless access points\n   Routers\n   Switches\n   NIC (Network Interface Controller/Card)\n   Transmission media\nThe Internet as a worldwide collection of computer networks:\n   DNS (Domain Name Server)\n   Hosting\n   The Cloud\n   Web servers and clients\nStar and Mesh network topologies
1.3.2 Wired and wireless networks, protocols and layers
Modes of connection:\n   Wired\n   Ethernet\n   Wireless\n   Wi-Fi\n   Bluetooth\nEncryption\nIP addressing and MAC addressing\nStandards\nCommon protocols including:\n   TCP/IP (Transmission Control Protocol/Internet Protocol)\n   HTTP (Hyper Text Transfer Protocol)\n   HTTPS (Hyper Text Transfer Protocol Secure)\n   FTP (File Transfer Protocol)\n   POP (Post Office Protocol)\n   IMAP (Internet Message Access Protocol)\n   SMTP (Simple Mail Transfer Protocol)\nThe concept of layers
1.4 Network security
1.4.1 Threats to computer systems and networks
Forms of attack:\n   Malware\n   Social engineering, e.g. phishing, people as the ‘weak point’\n   Brute-force attacks\n   Denial of service attacks\n   Data interception and theft\n   The concept of SQL injection
1.4.2 Identifying and preventing vulnerabilities
Common prevention methods:\n   Penetration testing\n   Anti-malware software\n   Firewalls\n   User access levels\n   Passwords\n   Encryption\n   Physical security
1.5 Systems software
1.5.1 Operating systems
The purpose and functionality of operating systems:\n   User interface\n   Memory management and multitasking\n   Peripheral management and drivers\n   User management\n   File management
1.5.2 Utility software
The purpose and functionality of utility software\nUtility system software:\n   Encryption software\n   Defragmentation\n   Data compression
1.6 Ethical, legal, cultural and environmental impacts of digital technology
1.6.1 Ethical, legal, cultural and environmental impact
Impacts of digital technology on wider society including:\n   Ethical issues\n   Legal issues\n   Cultural issues\n   Environmental issues\n   Privacy issues\nLegislation relevant to Computer Science:\n   The Data Protection Act 2018\n   Computer Misuse Act 1990\n   Copyright Designs and Patents Act 1988\n   Software licences (i.e. open source and proprietary)
2.1 Algorithms
2.1.1 Computational thinking
Principles of computational thinking:\n   Abstraction\n   Decomposition\n   Algorithmic thinking
2.1.2 Designing, creating and refining algorithms
Identify the inputs, processes, and outputs for a problem\nStructure diagrams\nCreate, interpret, correct, complete, and refine algorithms using:\n   Pseudocode\n   Flowcharts\n   Reference language/high-level programming language\nIdentify common errors\nTrace tables
2.1.3 Searching and sorting algorithms
Standard searching algorithms:\n   Binary search\n   Linear search\nStandard sorting algorithms:\n   Bubble sort\n   Merge sort\n   Insertion sort
2.2 Programming fundamentals
2.2.1 Programming fundamentals
The use of variables, constants, operators, inputs, outputs and assignments\nThe use of the three basic programming constructs used to control the flow of a program:\n   Sequence\n   Selection\n   Iteration (count- and condition-controlled loops)\nThe common arithmetic operators\nThe common Boolean operators AND, OR and NOT
2.2.2 Data types
The use of data types:\n   Integer\n   Real\n   Boolean\n   Character and string\n   Casting
2.2.3 Additional programming techniques
The use of basic string manipulation\nThe use of basic file handling operations:\n   Open\n   Read\n   Write\n   Close\nThe use of records to store data\nThe use of SQL to search for data\nThe use of arrays (or equivalent) when solving problems, including both one-dimensional (1D) and two-dimensional arrays (2D)\nHow to use sub programs (functions and procedures) to produce\nstructured code\nRandom number generation
2.3 Producing robust programs
2.3.1 Defensive design
Defensive design considerations:\n   Anticipating misuse\n   Authentication\nInput validation\nMaintainability:\n   Use of sub programs\n   Naming conventions\n   Indentation\n   Commenting
2.3.2 Testing
The purpose of testing\nTypes of testing:\n   Iterative\n   Final/terminal\nIdentify syntax and logic errors\nSelecting and using suitable test data:\n   Normal\n   Boundary\n   Invalid/Erroneous\nRefining algorithms
2.4 Boolean logic
2.4.1 Boolean logic
Simple logic diagrams using the operators AND, OR and NOT\nTruth tables\nCombining Boolean operators using AND, OR and NOT\nApplying logical operators in truth tables to solve problems
2.5 Programming languages and Integrated Development Environments
2.5.1 Languages
Characteristics and purpose of different levels of programming language:\n   High-level languages\n   Low-level languages\nThe purpose of translators\nThe characteristics of a compiler and an interpreter
2.5.2 The Integrated Development Environment (IDE)
Common tools and facilities available in an Integrated\nDevelopment Environment (IDE):\n   Editors\n   Error diagnostics\n   Run-time environment\n   Translators